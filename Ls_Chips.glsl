// Chips: show colour chips with names
// lewis@lewissaunders.com
// TODO:
//  o extract kerning pair metrics from the Source Sans font and try to use them?

#version 120
#extension GL_ARB_shader_texture_lod : enable

uniform float adsk_result_w, adsk_result_h, adsk_result_frameratio;
uniform sampler2D front, adsk_texture_grid;
uniform vec2 chip1pos, chip2pos, chip3pos;
uniform vec3 chip1col, chip2col, chip3col;
uniform bool chip1nearest, chip2nearest, chip3nearest, chip1override, chip2override, chip3override;
uniform float blockup;
uniform bool showblocky;
uniform bool voronoi;

vec2 res = vec2(adsk_result_w, adsk_result_h);
vec2 xy = gl_FragCoord.xy / res;

// Widths for each ASCII character, generated by /obj/font/charwidths in Ls_Chips.hip Houdini scene
const float charwidths[] = float[](0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.013000, 0.005811, 0.013125, 0.028232, 0.024609, 0.049561, 0.035957, 0.003486, 0.010869, 0.010869, 0.017432, 0.028096, 0.007998, 0.015039, 0.005811, 0.023447, 0.026113, 0.022832, 0.026934, 0.027207, 0.029531, 0.027686, 0.026250, 0.026865, 0.027139, 0.026182, 0.005811, 0.007998, 0.028096, 0.028096, 0.028096, 0.021533, 0.048603, 0.034863, 0.029805, 0.032266, 0.030898, 0.025361, 0.024541, 0.032676, 0.030420, 0.003145, 0.022285, 0.030830, 0.023926, 0.035000, 0.030215, 0.037119, 0.027686, 0.037256, 0.028574, 0.029668, 0.031855, 0.030352, 0.033018, 0.048672, 0.030625, 0.030146, 0.030078, 0.010938, 0.023516, 0.010938, 0.023721, 0.032539, 0.011484, 0.024199, 0.027344, 0.025362, 0.027344, 0.026865, 0.017431, 0.028985, 0.024268, 0.005469, 0.012920, 0.024609, 0.006221, 0.043477, 0.024268, 0.029463, 0.027344, 0.027344, 0.015654, 0.023105, 0.018662, 0.024063, 0.028027, 0.043545, 0.025908, 0.028164, 0.023994, 0.015244, 0.002461, 0.015244, 0.027207, 0.000000);

// Retrieves a colour from index i
vec3 getcol(int i) {
  vec2 uv;
  uv.y = float(i);
  uv.x = 0.0;
  uv += 0.5;
  uv /= 1024.0;
  vec3 texel = texture2D(adsk_texture_grid, uv).gba;
  return texel;
}

// Retrieves i'th character code in string from row, col
int getch(int row, int col, int i) {
  vec2 uv;
  uv.y = float(row);
  uv.x = float(col + i);
  uv += 0.5;
  uv /= 1024.0;
  float texel = texture2D(adsk_texture_grid, uv).g;
  return int(texel);
}

// Returns contribution of string from row, col at position where
float print(int row, int col, vec2 where, float size) {
  if(row == -1) {
    return 0.0;
  }

  float tracking = 0.011;
  vec2 stringuv = (xy - where) * (5.5 - size);
  if(stringuv.x < 0.0 || stringuv.y > 0.1 || stringuv.y < 0.0) return 0.0;

  // Which character are we in?  Sum widths of characters in string left to right
  // until we overtake current position
  int thischaridx = -1;
  int thischar = -1;
  float prevcharswidth = 0.0;
  for(int i = 0; i < 40; i++) {
    thischar = getch(row, col, i);
    if(thischar == 0) break; // End of string, they're null terminated in the texture
    float thischarwidth = (charwidths[thischar] + tracking) / adsk_result_frameratio;
    prevcharswidth += thischarwidth;
    if(prevcharswidth > stringuv.x) {
      thischaridx = i;
      prevcharswidth -= thischarwidth;
      break;
    }
  }

  // Give up if we're off the end of the string
  if(thischaridx == -1) return 0.0;

  // Where are we in the character?
  vec2 charuv = stringuv - vec2(prevcharswidth, 0.0);
  charuv.x *= adsk_result_frameratio;

  // Where is that in the font texture?
  int nth = thischar - 32;
  int chrow = nth / 10;
  int chcol = nth - (chrow * 10);
  vec2 charorigin = vec2(chcol, chrow) / 10.0;
  charorigin.x += 0.021;
  vec2 fontuv = charorigin + charuv;

  // Look up the SDF and step to it for antialiasing
  float sdf = texture2D(adsk_texture_grid, fontuv).r;
  float aa = 1.0 - smoothstep(0.5, 4.5, sdf);

  return aa;
}

// Return the index of the colour closest to col
int bestcol(vec3 col) {
  int best = -1;
  float lowest = 999.0;
  for(int i = 0; i < 213; i++) {
    float dist = length(col - getcol(i));
    if(dist < lowest) {
      lowest = dist;
      best = i;
    }
  }
  return best;
}

// Transform into UV coords in a chip rectangle
vec2 rectuv(vec2 origin, vec2 size) {
  return (xy - origin) / size;
}

// Return signed distance to rectangle
float rectsdf(vec2 origin, vec2 size) {
  vec2 d = max(origin - xy, xy - origin - size);
  d.x *= adsk_result_frameratio;
  return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));
}

void main() {
  vec3 bg = texture2D(front, xy).rgb;
  if(showblocky) {
    bg = texture2DLod(front, xy, blockup + 0.4).rgb;
  }

  vec4 chips = vec4(0.0);
  vec2 voronoi_pos[3];
  vec3 voronoi_col[3];

  for(int i = 0; i < 3; i++) {
    vec2 pos = chip1pos;
    vec3 col = chip1col;
    bool nearest = chip1nearest;
    bool override = chip1override;
    if(i == 1) {
      pos = chip2pos;
      col = chip2col;
      nearest = chip2nearest;
      override = chip2override;
    }
    if(i == 2) {
      pos = chip3pos;
      col = chip3col;
      nearest = chip3nearest;
      override = chip3override;
    }

    vec3 pickcol = texture2DLod(front, pos, blockup + 0.4).rgb;
    if(override) pickcol = col;

    int bestcolidx;
    vec3 bestcol;
    if(nearest) {
      bestcolidx = bestcol(pickcol);
      bestcol = getcol(bestcolidx);
    } else {
      bestcolidx = -1;
      bestcol = pickcol;
    }

    if(voronoi) {
      voronoi_pos[i] = pos;
      voronoi_col[i] = bestcol;
    }

    vec2 chipsize = vec2(0.08, 0.09 * adsk_result_frameratio);
    vec2 origin = pos + vec2(0.003, -chipsize.y-0.005);
    origin = max(origin, vec2(0.01, 0.01 * adsk_result_frameratio));
    origin = min(origin, vec2(0.99 - chipsize.x, 1.0 - 0.01 * adsk_result_frameratio - chipsize.y));
    vec2 chiptopleft = origin - vec2(0.003, -chipsize.y-0.005);
    float tagmatte = 1.0 - smoothstep(0.3333, 0.33334, rectuv(origin, chipsize).y);
    vec3 tagcol = vec3(0.9);
    vec3 fill = mix(bestcol, tagcol, tagmatte);

    float name = print(bestcolidx, 1, origin + vec2(0.00, 0.025), 1.0);
    fill = mix(fill, vec3(0.0), name);
    float line2 = print(bestcolidx+2, 1, origin + vec2(0.00, 0.01), -1.0);
    fill = mix(fill, vec3(0.4), line2);

    float rectmatte = 1.0 - smoothstep(0.005, 0.006, rectsdf(origin, chipsize));
    float cornermatte = 1.0 - smoothstep(0.0, 0.001, rectsdf(chiptopleft + vec2(0.0003, -0.02), vec2(0.02)));
    float matte = rectmatte + cornermatte - (cornermatte * rectmatte);

    float shadow = 1.0 - smoothstep(0.0, 0.1, rectsdf(origin, chipsize));
    shadow = pow(shadow, 4.0) * 0.75;
    float radial = smoothstep(0.0, 0.4, length((xy - chiptopleft) * vec2(adsk_result_frameratio, 1.0)));
    if(voronoi) {
      shadow = pow(shadow, 4.0) * 0.66;
    } else {
      shadow *= radial;
    }

    fill *= matte;
    matte = matte + shadow - (matte * shadow);
    chips = chips * (1.0 - matte) + vec4(fill, matte);
  }

  if(voronoi) {
    vec3 accum = vec3(0.0);
    float samples = 0.0;
    for(float sx = -0.5; sx <= 0.5; sx += 0.25) {
      for(float sy = -0.5; sy <= 0.5; sy += 0.25) {
        vec2 ixy = xy + (vec2(sx, sy) / res);
        float closest = 999.0;
        vec3 col = vec3(0.0);
        for(int i = 0; i < 3; i++) {
          float dist = length(ixy - voronoi_pos[i]);
          if(dist < closest) {
            closest = dist;
            col = voronoi_col[i];
          }
        }
        accum += col;
        samples++;
      }
    }
    bg = accum / samples;
  }

  vec3 comped = bg * (1.0 - chips.a) + chips.rgb;

  gl_FragColor = vec4(comped, chips.a);
}
